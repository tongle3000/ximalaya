##  下拉刷新 
    // 1.下拉刷新
    Home -> index.tsx  FlatList 组件


    // 3.下拉刷新;  声明个接口,下面 Home 组件引入.
    interface IState {
        refreshing:boolean;
    }


    class Home extends React.Component<IProps, IState> { // 4.下拉刷新; 

	// 5.下拉刷新; 先在 state 里给 refreshing 定义个默认值
	state = {
		refreshing: false,
	}





    // 2.下拉刷新; 这里要控制逻辑状态, 不然一直出现菊花图标在加载. 上面 3 声明个接口.
	onRefresh = () => {
		// 6.下拉刷新; (1)修改刷新状态为 true
		this.setState({
			refreshing: true,
		});
		// 6.下拉刷新; (2)获取数据. 在componentDidMount 里的代码, 只刷新列表 channels
		const { dispatch } = this.props;
		dispatch({
			type: 'home/fetchChannels',
			// 9 下拉刷新; 传递个回调函数 callback. 但是这个 dispatch 改了,就要到 home.ts 里改定义的带 callback
			callback: () => {
				// 6.下拉刷新; (3)修改刷新状态为 false. 这个 false 状态不能在 aciton 一发起就改变状态,应该等 action 执行完, 数据加载好,再改状态.
				this.setState({
					refreshing: false,
				});
			}
		});


		// // 6.下拉刷新; (3)修改刷新状态为 false. 这个 false 状态不能在 aciton 一发起就改变状态,应该等 action 执行完再改状态.
		// this.setState({
		// 	refreshing: false,
		// });
		
	}


    // 7.下拉刷新;
		const {refreshing} = this.state;
		return (
			// 9 首页列表
			<FlatList
				ListHeaderComponent={this.header}
				data={channels}
                renderItem={this.renderItem}
				keyExtractor={ this.keyExtractor}
				
				// 1.下拉刷新
				onRefresh={ this.onRefresh } // onRefresh 不能单独使用, 要refreshing={true}
				refreshing={refreshing} // 8.下拉刷新; 值true 改为 refreshing ,{true}=>{refreshing}, 测试 能刷新. 如果看不到效果,可以到 yapi 列表 高级MOCK 脚本 开 mock 脚本输入: delay=3000 就是延迟 3 秒.拖到那个组件等待着看.

			/>
		);

##  home.ts 

        // ⑥ 首页列表 ;
		// 9.下拉刷新;  这里第一个参数是 action, 就是 index.tsx dispatch {这里面的内容}, 带了 type 和 callback 函数.所以下面我们可以拿到{type, callback},这里只要 callback

		*fetchChannels(/*这里第一个参数是 action */{callback},{call, put}) {
				const {data} = yield call(axios.get, CHANNEL_URL);
				yield put({
					type: 'setState',
					payload: {
						channels: data.result, // 因为数据里面 data 还包了一个对象 result
					}
				});
                
				// 10.下拉刷新; 如果是个函数 ,我们执行 callback 方法.
				if(typeof callback === 'function') {
					callback();
				}
			}




		// ⑥ 首页列表 ; 
		// *fetchChannels(_,{call, put}) {
		// 	const {data} = yield call(axios.get, CHANNEL_URL);
		// 	yield put({
		// 		type: 'setState',
		// 		payload: {
		// 			channels: data.result, // 因为数据里面 data 还包了一个对象 result
		// 		}
		// 	})
		// }