视频: http://39.105.213.120/mock/11/bear/category (能访问到)

##  10-2 分类模块,要进入用户选择的类别的.cd
    (react-native 之前有storage 库,0.6 后面,就托管给第三方了),所以我们要安装下.

 -> 安装: yarn add @react-native-community/async-storage   1.9.0
        官网: https://react-native-community.github.io/async-storage/docs/install

    苹果: npx pod-install
                                    cd ios
                                    pod install
                                    cd ..

    yarn ios


    网上也已经有了 第二次 进行封装, 支持 react-native 和 浏览器.
 -> 安装: yarn add react-native-storage         1.0.1 

    config -> storage.ts
        import AsyncStorage from '@react-native-community/async-storage';
        import Storage, { LoadParams } from 'react-native-storage';


        // 声明个 storage, 配置属性:
        const storage = new Storage({
            size: 1000, // 最大容量
            storageBackend: AsyncStorage, // 数据引擎; 浏览器端传入: window.localstorage;  不设置这个,Storage就会将 数据保存在内存中, 一旦退出了,就没了.
            defaultExpires:  1000*3600*24*7, // 过期时间: 7 天 ; null 永远不过期;
            enableCache:  true, // 设置缓存
            sync:{}, // 当我们从 storage 里获取数据时,没有数据,或者已经过期,就会调用这里.先置空.
        });

        // 从新定义 load ,为了 dva使用storage,用 load时,不会报错.
        const load = (params: LoadParams) => {
            return storage.load(params); 
        }

        export {load};

        export default storage;

        // load<T = any>(params: LoadParams): Promise<T>;

##  10-3 请求类别接口,保存本地中.

    models -> 新建 category.ts

        import storage, { load } from '@/config/storage';
        import axios from 'axios';
        import { Effect, Model, SubscriptionsMapObject } from 'dva-core-ts';
        import { Reducer } from 'redux';


        //  声明一个 category url
        const CATEGORY_URL='/mock/11/bear/category';

        // 3.设置数组没项,有哪些属性:

        interface ICategory {
            id: string;
            name: string;
            classify?: string; // 分组,不一定都分了.加个?;
        }

        // 2. state 分为:我的分类, 所有分类
        interface CategoryModelState {
            myCategorys: ICategory; // 这个数组的每一项又是什么呢, 转 3 定义 ICategory 有哪些属性;
            categorys: ICategory;
        }
        
        // 1.先声明一个 model 接口,继承与 dva 中的  Model
        interface CategoryModel extends Model {
            namespace: 'category';
            state: CategoryModelState; // 上面 2 定义.
            // 4. reducers
            reducers:{
                setState: Reducer<CategoryModelState>, // Reducer从 redux 里导入. 他能接收个泛型(action)
            },
            // 5. effects 异步加载数据
            effects: { // 先定义个异步加载 数据函数,等会到 storage获取
                loadData: Effect
            }, 
            // 6.订阅,用来订阅数据源,去调用相应的 action, 这里的作用减少去请求数据的接口
            subscriptions: SubscriptionsMapObject,
        }

        // 7. 定义一个初始数据;
        const initialState = {
            myCategorys: [ // 这里不是空的数组. 起始值有: 推荐, vip
                {
                    id:'home',
                    name: '推荐',
                },
                {
                    id: 'vip',
                    name: 'Vip',
                }
            ], 
            categorys:[],
        }


        // 8.声明个 categoryModel 
        const categoryModel: CategoryModel = {
            namespace: 'category',
            state: initialState,
            reducers: {
                setState(state, {payload}) {
                    return {
                        ...state,
                        ...payload,
                    }
                }
            },
            effects: {
                *loadData(_,{put,call}) {
                    // 从 storage 里获取数据;  // storage 里的 load 继承 LoadParams, 有 KEY 的属性.
                    const myCategorys = yield call(load, {key: 'myCategorys'});  // 拿到 我的分类 的数据;
                    const categorys = yield call(load, {key:'categorys'});      // 拿到 所有分类 的数据; 
                    
                    // 发起一个 action, 将数据保存到 state 里; 要先判断 myCategorys 存在不存在,存在,再发起 action;
                    if(myCategorys) {
                        yield put({
                            type: 'setState',
                            payload: {
                                myCategorys,
                                categorys,
                            },
                        });
                    } else { // 如果不存在,只保存 所有分类;
                        yield put({
                            type: 'setState',
                            payload: {
                                myCategorys,
                                categorys,
                            },
                        });
                    }
                },
            },
            subscriptions: { // 只要被加载,就会执行这个 dispatch
                subscriptionsDispatch({dispatch}) { // setup 这个名字可以随便取. setup 改成 subscriptionsDispatch;
                    dispatch({type:'loadData'})
                },
                // 这里再定义一个 同步数据,给  config -> storage 里的 sync:{} 使用. 
                asyncStorage() {
                    // 实际上, 下面 2 个函数 , 也可以定义在 外面的 export 的上面.并不一定 一定要定义在这里;
                    // categorys
                    storage.sync.categorys = async () => { // async关键字声明 异步函数,  ES7 异步; 
                        //原理: 封装了自动执行器的一个生成器函数,并且会返回一个 promise 对象.
                        const data = await axios.get(CATEGORY_URL); // 最上面 声明 CATEGORY_URL
                        // console.log(data);// 里面是 {status:100, msg:'', data:[]}
                        return data.data; // 所以这里使用,data.data.   
                        // 要么使用下面这样
                        // const {data} = await axios.get(CATEGORY_URL); // 这里 data 使用对象解构. 加个大括号;
                        // return data;
                    }

                    // myCategorys // 直接返回 null 因为 myCategorys, 并不保存到后台去,只保存在本地.
                    storage.sync.myCategorys = async () => {
                        return null; // 直接返回 null 因为 myCategorys, 并不保存到后台去,只保存在本地.
                    }
                }

            },
        }


        export default categoryModel; // 再到 models -> index.ts 引入这个 category model;

  - models -> index.ts   // 再到 models -> index.ts 引入这个 category model;
        const models =[home,homeNum, category];

        // 导出每个 model 的 类型
        export type RootState = {
            home: typeof home.state;
            homeNum: typeof homeNum.state;
            category: typeof category.state;
            loading: DvaLoadingState;
        }
        export default models;


##  10-4 类别页面 布局 和 样式; 
  - pages -> 新建 Category -> index.tsx

  - navigator -> index.tsx 引入分类页面.
        import Category from '@/pages/Category';

        export type RootStackParamList = {
            ...
            Category: undefined;
        };

        <Stack.Screen
            options={{ title: '分类'}}
            name="Category"
            component={Category}
        />

  - pages -> views -> TopTabBarWrapper.tsx 定义分类的按钮 链接.

        添加链接 onPress={this.goCategory}
        <Touchable style={styles.categoryBtn} onPress={this.goCategory}>
			<Text style={textStyle}>分类</Text>
		</Touchable>

        // 加入到 <IProps> { 这里 }
        // 链接 分类
        goCategory = () => {
            const {navigation} = this.props;
            navigation.navigate('Category');
        }

  - pages -> 新建 Category -> index.tsx
        import { RootState } from '@/models';
        import { ICategory } from '@/models/category';
        import { viewportWidth } from '@/utils';
        import React from 'react';
        import { StyleSheet, Text, View } from 'react-native';
        import { connect, ConnectedProps } from 'react-redux';

        const mapStateToProps = ({category}: RootState) => ({
            myCategorys: category.myCategorys,
            categorys: category.categorys,
        });

        const connector = connect(mapStateToProps);

        type ModelSate = ConnectedProps<typeof connector>;

        interface IProps extends ModelSate {};

        // 定义我的分类
        interface IState {
            myCategorys: ICategory[],
        }

        // 计算宽度
        const parentWidth = viewportWidth -10;
        const itemWidth = parentWidth/4;

        class Category extends React.Component<IProps, IState> {
            // 这里不会, 我的分类 这里是要保存在用户本地,而不用保存到服务器上.
            state = {
                myCategorys: this.props.myCategorys,
            }
            
            renderItem = (item: ICategory, index: number) => {
                return ( // 所有遍历出来的,,都要定义 key
                    <View key={index} style={styles.items}>
                        <View style={styles.itemText}>
                            <Text>{item.name}</Text>
                        </View>
                    </View>
                );
            }


            render() {
                const {myCategorys} = this.state; // 这里是不 porops
                const {categorys}= this.props;
                // console.log('=======',this.props);
                /**
                * 需要对 categorys 重新分组 (推荐,知识,娱乐,生活)
                * data 里面的 key 就是, 值是: id name classify
                * 
                * 这里要安装第三方库, yarn add lodash
                * 
                */
                return(
                    <View style={styles.container}>
                        <Text style={styles.classifyName}>我的分类</Text>
                        <View style={styles.classifyView}>{ myCategorys.map(this.renderItem) }</View>

                        <Text style={styles.classifyName}>所有分类</Text>
                        <View style={styles.classifyView}>{ categorys.map(this.renderItem) }</View>
                    </View>
                )
            }
        }

        const styles = StyleSheet.create({
            container: {
                flex: 1,
                backgroundColor:'#f3f6f6',
            },
            classifyName:{
                fontSize:16,
                marginBottom: 8,
                marginTop: 14,
                marginLeft:10,
            },
            classifyView:{
                flexDirection:'row',
                flexWrap:'wrap',
                padding:5,
            },
            items:{
                width: itemWidth,
                marginVertical: 5,
                height:38,
            },
            itemText: {
                flex:1,
                justifyContent:'center',
                alignItems:'center',
                backgroundColor:'#fff',
                marginHorizontal:5,
                borderRadius:4,
            },
        })

        export default connector(Category); // connector


##  10-5 4里读的所有分类数据,是没分出来的.
    /**
         * 需要对 categorys 重新分组 (推荐,知识,娱乐,生活)
         * data 里面的 key 就是, 值是: id name classify
         * 
         * 这里要安装第三方库, yarn add lodash
         * 
    */
  - 安装: yarn add lodash      (官网: https://www.lodashjs.com/ , 只需要用到里面的 函数 Function )
    安装它的声明: yarn add @types/lodash

    pages -> Category -> index.tsx
    引入: import _ from 'lodash';

        // console.log('=======',this.props);
        /**
         * 需要对 categorys 重新分组 (推荐,知识,娱乐,生活)
         * data 里面的 key 就是, 值是: id name classify
         * 
         * 这里要安装第三方库, yarn add lodash, 我们使用的是 它的函数 FUNCTION ; 具体地址: https://www.lodashjs.com/docs/lodash.groupBy
         * _.groupBy(collection, [iteratee=_.identity])
         * 
            _.groupBy([6.1, 4.2, 6.3], Math.floor);
            // => { '4': [4.2], '6': [6.1, 6.3] }
            
            // The `_.property` iteratee shorthand.
            _.groupBy(['one', 'two', 'three'], 'length');
            // => { '3': ['one', 'two'], '5': ['three'] }

            {
                "id": "2",
                "name": "小说",      
                "classify": "推荐"   // classify 属于哪个小组. (推荐,知识,娱乐,生活这些组.)
            },
         */
        const classifyGroup = _.groupBy(categorys, (item) => item.classify); // 然后到下面遍历这个 classifyGroup ,返回一个组成聚合的对象。


                {
                    Object.keys(classifyGroup).map( /**key */ classify => {
                        return(
                            <View key={classify}>
                                <Text style={styles.classifyName}>{classify}</Text>
                                {/* <View style={styles.classifyView}>{ categorys.map(this.renderItem) }</View> 
                                     categorys   改为:  classifyGroup[classify]
                                */}
                                <View style={styles.classifyView}>{ classifyGroup[classify].map(this.renderItem) }</View>
                            </View>
                        )
                    })
                }

                {/* 
                    初始的写法,改成上面的.
                    <Text style={styles.classifyName}>所有分类</Text>
                    <View style={styles.classifyView}>{ categorys.map(this.renderItem) }</View>  
                */}




##  10-6 分类页面 右上角加 按钮 "编辑"    ( 安装: yarn add react-navigation-header-buttons, 第三方 右上角按钮组件库.)
    有 2 种方法
    1. 可以在 <Stack.Screen onptions ={{ ... headerRight:()=> <组件名 /> }}>
    2. 在 Category -> index.tsx 
        // 1.右上角按钮: 编辑 
        constructor(props: IProps) {
            super(props);
            props.navigation.setOptions({ // 到上面定义 navigation  // 2.右上角按钮: 编辑  
                headerRight: () => <HeaderRightBtn /> // 这个按钮 是根据状态 显示不同文本的. 不用下面的方法, 直接保存 dva 中. 同级目录新建个 HeaderRightBtn 组件.
            }); 
            // props.navigation.setParams({
            //     title: '编辑'
            // })
            // props.route.params.title
        }

        interface IProps extends ModelSate {
            // 2.右上角按钮: 编辑 
            navigation: RootStackNavigation;
        };

        - HeaderRightBtn.tsx 文件  
            安装: yarn add react-navigation-header-buttons ,  安装后,可以拿到 HeaderButtons 

            /**
            * 编辑 / 完成 按钮
            * 3.右上角按钮: 编辑 
            */
            import React from 'react';
            import { HeaderButtons, Item } from 'react-navigation-header-buttons';


            class HeaderRightBtn extends React.Component{
                render() {
                    return (
                        // 这里不自己写按钮,,用个第三方的库(方便显示多个按钮,为了以后的扩展考虑). HeaderButtons包裹, 里面可以放很多按钮, Item 就是按钮
                        <HeaderButtons> 
                            <Item title='编辑' />
                        </HeaderButtons>
                    )
                }
            }

            export default HeaderRightBtn;

            // 4.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit

        - models -> category.ts
        
            interface CategoryModelState {
                // 4.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit
                isEdit: boolean;
                ...
            }

            const initialState = {
                // 5.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit
                isEdit: false, // 转 上 effects 里声明 toggle: Effect;
                ...
            }    

            interface CategoryModel extends Model {
                effects: { 
                    loadData: Effect;

                    // 6.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit ; // 声明函数 toggle: Effect; 这个函数起切换 编辑/完成 状态用的.
                    toggle: Effect; // 这个函数起切换 编辑/完成 状态用的.
                }, 
            }

            const categoryModel: CategoryModel = {
                ...
                effects: {
                    ...
                    // 7.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit ; // 声明函数 toggle: Effect; 
                    *toggle({payload},{put, select}) { // 将有副作用的放到这个函数里
                        const category = yield select(({category}: RootState) => category);
                        yield put({
                            type: 'setState',
                            payload:{             // payload 传递参数 取反
                                isEdit: !category.isEdit, // 执行以下,取反,赋给 isEdit;
                            }
                        })
                    }, // 8.右上角按钮: 编辑 ;接下来是去 HeaderRightBtn.tsx 页面,给按钮添加点击事件,执行这个 action
                }
            }


        - Category -> HeaderRightBtn.jsx 文件

            // 8.右上角按钮: 编辑 ;接下来是去 HeaderRightBtn.tsx 页面,给按钮添加点击事件,执行这个 action
            onPress={onSubmit} // 不能写在这个组件里面,应该调用父组件穿过来的一个函数, 上面声明个接口.

            interface IProps {
                onSubmit: () => void; //  9. 右上角按钮: 编辑 ;定义这个接口
            }


            render() { 
                //  10. 右上角按钮: 编辑 ; 从 props 中拿到 onSubmit, 再传给下面 onPress;
                const {onSubmit} = this.props;
                ...
            }


        - Category -> index.tsx

            headerRight: () => (
				<HeaderRightBtn
					onSubmit={this.onSubmit}/* 12. 右上角按钮: 编辑 ; */
				/>
			), // 这个按钮 是根据状态 显示不同文本的. 不用下面的方法, 直接保存 dva 中. 同级目录新建个 HeaderRightBtn 组件.


            // 12. 右上角按钮: 编辑 ;  定义 onSubmit 函数, 给 HeaderRightBtn 组件使用;
            onSubmit = () => {
                const { dispatch } = this.props; // 从 Props 中拿到 dispatch
                dispatch({
                    type: 'category/toggle',
                });
            }; // 13. 右上角按钮: 编辑 ; 再转到 HeaderRightBtn.tsx 我们要获取到 dva 中 编辑的状态.




        - Category -> HeaderRightBtn.jsx 文件
            // 13. 右上角按钮: 编辑 ; 再转到 HeaderRightBtn.tsx 我们要获取到 dva 中 编辑的状态.
            const mapStateToProps = ({category}:RootState) => {
                return {
                    isEdit: category.isEdit,
                }
            };

            const connector = connect(mapStateToProps);

            type ModelState = ConnectedProps<typeof connector>;

            interface IProps extends ModelState {
                onSubmit: () => void; //  9. 右上角按钮: 编辑 ;定义这个接口
            }


            // 14. 右上角按钮: 编辑 ; 添加 isEdit
            const {onSubmit, isEdit} = this.props;

            // 15. 右上角按钮: 编辑 ; 添加 isEdit 判断:如果是编辑状态,就显示完成, 如果不是,就是编辑.
            title={isEdit ? '完成' : '编辑'} 

##  10-6 修改 ios 上的返回按钮:
    navigator -> index.tsx 文件 Stack.Navigator -> screenOptions 文件中 设置 headerBackTitleVisible

    screenOptions={{
        headerBackTitleVisible:false, // 设置 Back 不可见;
        headerTintColor: '#333', // 设置 标题 和 '返回箭头' 颜色;
        ...
    }}
##  10-6 判断状态栏高度:  (headerStatusBarHeight: StatusBar.currentHeight, // 视频有加这个,我加这个, IOS headerTitle不显示,且高度没有.)
    Stack.Navigator -> screenOptions 加上 判断, 只要 android(安卓) 上执行

    ... Platform.select({
        android :{
            headerStatusBarHeight: StatusBar.currentHeight
        }
    }),



##  10-7 新增类别 和 删除类别; 添加 编辑中 选中的 状态 ; 
  - Category -> item.tsx

    IProps 里添加个状态: 是否选中 当前 item , 还要添加 个是否处于编辑状态 isEdit;

    interface IProps {
        data: ICategory;
        selected: boolean; // 1. 新增类别 和 删除类别
        isEdit: boolean;   // 1. 新增类别 和 删除类别
    }


   <View key={data.id} style={styles.items}>
                <View style={styles.itemText}>
                    <Text>{data.name}</Text>

                    {
                        // 2. 新增类别 和 删除类别如过时编辑状态: 再定义样式
                        isEdit && (
                            <View style={styles.EditIcon}>
                                <Text style={styles.EditIconText}>{selected ? '-' : '+'}</Text>
                            </View>
                        )
                    }

                </View>
   </View>


    EditIcon:{
        position: 'absolute',
        top: -5,
        right:-5,
        height:16,
        width:16,
        justifyContent:'center',
        alignContent: 'center',
        backgroundColor:'#f86442',
        borderRadius:8,
    },
    EditIconText:{
        color:'#fff',
    },

  - Category -> index.tsx

    接收 isEdit
    先 要拿到 model 里的 isEdit
    const mapStateToProps = ({ category }: RootState) => ({
        ...
        isEdit: category.isEdit,
    });

    renderItem = (item: ICategory, index: number) => {
        const {isEdit} = this.props; // 4. 新增类别 和 删除类别如过时编辑状态:
        return (
            <Item 
                key={item.id} 
                data={item} 
                // 5. 新增类别 和 删除类别如过时编辑状态: 
                isEdit={isEdit}
                // 6. 新增类别 和 删除类别如过时编辑状态: selected 选泽了,传 true. 但是我们还有个没选中的. 要新建个 renderUnSelectItem 函数
                selected={true}
            />
        )
    }

    // 7. 新增类别 和 删除类别如过时编辑状态: selected 选泽了,传 true. 但是我们还有个没选中的. 要新建个 renderUnSelectItem 函数
    renderUnSelectItem = (item: ICategory, index: number) => {
        const {isEdit} = this.props; 
        return <Item key={item.id} data={item} isEdit={isEdit} selected ={false} />
    }

    <View style={styles.classifyView}>
		{classifyGroup[classify].map(
            // 8. 新增类别 和 删除类别; this.renderItem 改为 this.renderUnSelectItem;
            this.renderUnSelectItem,
		)}
	</View>

##  10-7 新增类别 和 删除类别; onLongPress 长按 item 也进入 "编辑" 状态; 
    给 renderItem 里面的 item 外面包一个 Touchable 组件, 上面的 // 7.新增类别 和 删除类别 的代码改成下面的.

    // 8. 新增类别 和 删除类别; 给 renderItem 里面的 item 外面包一个 Touchable 组件
    return <Touchable key={item.id} onLongPress={this.onLongPress}><Item data={item} isEdit={isEdit} selected ={false} /></Touchable>

    // 9. 新增类别 和 删除类别; 定义 onLongPress 函数; 直接调用, onSubmit 里面的代码, 调用 dispatch 就可以了.改成 setState,再加传参数;
    onLongPress = () =>{
        const { dispatch } = this.props; // 从 Props 中拿到 dispatch
		dispatch({
            type: 'category/setState',
            payload: {
                isEdit: true, //进入 "编辑" 状态;
            }
		});
    }
##  10-7 新增类别 和 删除类别; 解决编辑状态 退出后,再进入还是编辑状态的问题.
    这时,只要在 Category -> index.tsx 添加个生命周期函数. componentWillUnmount, 执行 个 dispatch 传 isEdit:false就可以了;
    componentWillUnmount(){
        const {dispatch} = this.props;
        dispatch({
            type: 'category/setState',
            payload:{
                isEdit:false,
            },
        })
    }


##  10-7 新增类别 和 删除类别; 点击 item 执行添加到我的分类里.
    给 renderItem 里面的 Touchable 添加 onPress , 传入参数

    11. 新增类别 和 删除类别; 点击 item 执行添加到我的分类里.onPress, 需要传递参数:item index, 添加的是那个?
    <Touchable key={item.id} 
        onPress={() => this.onPress(item, index)} 

    onLongPress={this.onLongPress}><Item data={item} isEdit={isEdit} selected ={false} /></Touchable>


    // 12. 新增类别 和 删除类别; 点击 item 执行添加到我的分类里.onPress,需要传递参数:item index, 添加的是那个?
    onPress = (item:ICategory, index:number) => {
        const {isEdit} = this.props;
        const {myCategorys} = this.state;
        if(isEdit) { // 处于编辑状态下,才有用.
            this.setState({ 
                myCategorys: myCategorys.concat([item]),// 用 push 都是在原来的数据上进行修改的; 在 react中, 最好是返回个新的数组.concat;
            })
        }
    }


    <View style={styles.classifyView}>
		{classifyGroup[classify].map(
            // this.renderUnSelectItem,
            // 13. 新增类别 和 删除类别; 解决添加到 我的分类里后 在所有分类里不显示;  把上面这句改为下面:
            (item, index) => {
                if(myCategorys.find(selectedItem => selectedItem.id === item.id)) {
                    // 如果在 我的分类 里找到了选中的 Item, 所有分类里我们就不返回了这个 item;
                    return null;
                }
                return this.renderUnSelectItem(item, index); // 其他没找到的,继续返回.
            }
        )}
	</View>

##  10-7 新增类别 和 删除类别; 点击 我的分类 里的 item 删除 item, 然后 item 返回到所有分类里.
    添加一个参数, 判断在 我的分类 里是否已经选择.
    在 renderItem 和 renderUnSelectItem 函数里的 onPress 事件里,都传入第三个参数, 判断是 已选择,还是 未选择.

    renderUnSelectItem 里传 false
    renderItem true
    在 onPress 函数里, 定义 selected: boolean

    // 20. 新增类别 和 删除类别; 点击 我的分类 里的 item 删除 item, 然后 item 返回到所有分类里.在 renderItem 和 renderUnSelectItem 函数里的 onPress 事件里,都传入第三个参数, 判断是 已选择,还是 未选择.renderUnSelectItem 里传 false;
        return <Touchable key={item.id} onPress={() => this.onPress(item, index, false)} onLongPress={this.onLongPress}><Item data={item} isEdit={isEdit} selected ={false} /></Touchable>


    // 21. 新增类别 和 删除类别; 点击 我的分类 里的 item 删除 item, 然后 item 返回到所有分类里.在 renderItem 和 renderUnSelectItem 函数里的 onPress 事件里,都传入第三个参数, 判断是 已选择,还是 未选择.renderItem 里传 true;
            <Touchable key={item.id} onPress={() => this.onPress(item, index, true)} onLongPress={this.onLongPress}>
            <Item 
                key={item.id} 
                data={item} 
                // 5. 新增类别 和 删除类别如过时编辑状态: 
                isEdit={isEdit}
                // 6. 新增类别 和 删除类别如过时编辑状态: selected 选泽了,传 true. 但是我们还有个没选中的. 要新建个 renderUnSelectItem 函数
                selected // 可以简写成 selected === selected={true}
            /></Touchable>

    
    // 22. 新增类别 和 删除类别; 点击 我的分类 里的 item 删除 item, 然后 item 返回到所有分类里.传入第三个参数 myCategorysSelected, 判断是否选择.
    onPress = (item:ICategory, index:number, myCategorysDelete:boolean) => {
        const {isEdit} = this.props;
        const {myCategorys} = this.state;
        if(isEdit) { // 处于编辑状态下,才有用.
            // 23. 新增类别 和 删除类别; 点击 我的分类 里的 item 删除 item, 然后 item 返回到所有分类里.传入第三个参数 myCategorysSelected, 判断是否选择.
            if(myCategorysDelete) {
                this.setState({ 
                    myCategorys: myCategorys.filter(DeleteItem => DeleteItem.id !== item.id ), // 过滤掉 我的分类 删除的 id 不是 所有分类item 里的 id
                })
            } else {
                // 还没选到 我的分类 里的, 追加进去.
                this.setState({ 
                    myCategorys: myCategorys.concat([item]),// 用 push 都是在原来的数据上进行修改的; 在 react中, 最好是返回个新的数组.concat;
                })
            }
            
        }
    }

##  10-7 新增类别 和 删除类别; 将数据 保存到 本地存储中, 并保存到 dva 仓库里;
 -  models -> category.ts  30, 31 两步;

        // 7.右上角按钮: 编辑 ; 转到 models -> category.ts 定义编辑的状态: isEdit ; // 声明函数 toggle: Effect; 
        *toggle({payload},{put, select}) { // 将有副作用的放到这个函数里
            const category = yield select(({category}: RootState) => category);
            yield put({
                type: 'setState',
                payload: { // payload 传递参数 取反
                    isEdit: !category.isEdit, // 执行以下,取反,赋给 isEdit;
                    // 31.新增类别 和 删除类别; 将数据 保存到 本地存储中, 并保存到 dva 仓库里; 同样,我的分类 的数据也要保存到 本地的 dva 仓库里面;
                    myCategorys: payload.myCategorys,
                }
            });

            // 30.新增类别 和 删除类别; 将数据 保存到 本地存储中, 并保存到 dva 仓库里; 如果分类处于编辑状态, storage.save()
            if( category.isEdit) {
                storage.save({
                    key: 'myCategorys',
                    data: payload.myCategorys,
                })
            }

        }, // 8.右上角按钮: 编辑 ;接下来是去 HeaderRightBtn.tsx 页面,给按钮添加点击事件,执行这个 action
 -  Category -> index.tsx
    在页面里,点击"完成",把数据传到 storage.save 保存,  ( 33,34)

    onSubmit = () => {
        const { dispatch } = this.props; // 从 Props 中拿到 dispatch;
        const { myCategorys } = this.state; // 33.新增类别 和 删除类别; 将数据 保存到 本地存储中, 并保存到 dva 仓库里;点击 '完成' 保存数据;
		dispatch({
            type: 'category/toggle',
            payload: { // 34.新增类别 和 删除类别; 将数据 保存到 本地存储中, 并保存到 dva 仓库里;点击 '完成' 保存数据;
                myCategorys,
            }
		});
    }; // 13. 右上角按钮: 编辑 ; 再转到 HeaderRightBtn.tsx 我们要获取到 dva 中 编辑的状态.
    

##  10-7 新增类别 和 删除类别; 推荐 vip 不能编辑;
  - Category -> index.tsx
        // 40.新增类别 和 删除类别; 推荐 vip 不能编辑; 定义个数组;
        const fixedItems = [0, 1]; // 第 0, 1项;

    renderItem 函数里,
        // 41.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值;
        const disabled = fixedItems.indexOf(index) > -1;

    <Item 
        disabled={disabled} // 42.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值; 转 item 子 组件,增加这个属性.
        ...
    />
  - Item.tsx

    interface IProps {
        ...
        disabled: boolean; // 43.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值; 转 item 子 组件,增加这个属性.
    }

    <View style={[styles.itemText, /* disabled 样式,要改成数组加[]. */disabled && styles.disabled]}>
        <Text>{data.name}</Text>
                    {
                        // 45.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值; 也不是 disabled 状态.
                        isEdit && !disabled && (
                            <View style={styles.EditIcon}>
                                <Text style={styles.EditIconText}>{selected ? '-' : '+'}</Text>
                            </View>
                        )
                    }
    </View>

    再是删除的时候, 我们也要给 disabled 判断.
    Category -> index.tsx   onPress 函数里
        // 46.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值;
        const disabled = fixedItems.indexOf(index) > -1;
        if(disabled) return; // 视频这句是直接放上面这句下面的, 点击所有分类 的前 2 项,会添加不了.所以我把这个直接放到了 删除 里面


        // 46.新增类别 和 删除类别; 推荐 vip 不能编辑; 判断一个值;
        const disabled = fixedItems.indexOf(index) > -1;

        if(isEdit) { // 处于编辑状态下,才有用.
            if(myCategorysDelete) {
                if(disabled) return;                           // 放在了这里
                ...
            } else {
               ...
            }
            
        }

##  10-9 类别拖拽 (第三方库)
    安装: yarn add react-native-drag-sort
    Category -> index.tsx

        引入 {DragSortableView } 组件

        import { DragSortableView } from 'react-native-drag-sort';

        {/* 1.10-9 类别拖拽  {myCategorys.map(this.renderItem)} 改成 可拖拽的组件 DragSortableView*/}
                    <DragSortableView 
                        dataSource={myCategorys}
                        renderItem={this.renderItem}
                        sortable={isEdit} // 只有在编辑状态下,可以拖拽. 从 this.props 里取isEdit;
                        keyExtractor={ item => item.id} // 指定 Key 值;
                        onDataChange={this.onDataChange} // 拖拽之后的回调 函数.
                        parentWidth={parentWidth} // 从 item中导入的
                        childrenHeight={itemHeight}
                        childrenWidth={itemWidth}
                        onClickItem={this.onClickItem} // 4.10-9 类别拖拽; 点击事件;  转上面 要改这个方法;
                        fixedItems={fixedItems}// // 6.10-9 类别拖拽; 点击事件,可以接受 2 个参数, data item 第一第二个不能拖拽; 
                        marginChildrenBottom={itemMarginBottom}
                    />


##  10-10 根据我的分类,动态生成标签导航器 和 model
  - HomeTabs.tsx 

        import IconFont from '@/assets/iconfont';
        import { RootState } from '@/models';
        import { ICategory } from '@/models/category';
        import Home from '@/pages/Home';
        import indexNum from '@/pages/Home/indexNum';
        import TopTabBarWrapper from '@/pages/views/TopTabBarWrapper';
        import {
            createMaterialTopTabNavigator,
            MaterialTopTabBarProps,
        } from '@react-navigation/material-top-tabs';
        import React from 'react';
        import { StyleSheet } from 'react-native';
        import { connect, ConnectedProps } from 'react-redux';

        // 1.10-10 根据我的分类,动态生成标签导航器 和 model; 创建HomeParamList, 传给Tab组件;
        export type HomeParamList = {
            // home: undefined;
            [key: string]: {
                namespace:string;
            }
        };
        const Tab = createMaterialTopTabNavigator<HomeParamList>();

        const mapStateToProps = ({ category }: RootState) => {
            return {
                myCategorys: category.myCategorys,
            };
        };
        const connector = connect(mapStateToProps);

        type ModeState = ConnectedProps<typeof connector>;

        interface IProps extends ModeState {}
        // end 1.10-10 根据我的分类,动态生成标签导航器 和 model; 创建HomeParamList, 传给Tab组件;

        class HomeTabs extends React.PureComponent<IProps> {
            // 2.10-10 根据我的分类,动态生成标签导航器 和 model; IProps

            // 8.修改首页顶部; 这个可以返回一个组件. 他能接收 props:MaterialTopTabBarProps, 还能接收 MaterialTopTabBar 组件
            renderTabBar = (props: MaterialTopTabBarProps) => {
                // 9.修改首页顶部;  pages -> views -> TopTabBarWrapper.tsx 自定义组件,下面直接引入这个组件. 传入{...props}
                return <TopTabBarWrapper {...props} />;
            };

            // 6.10-10 根据我的分类,动态生成标签导航器 和 model; renderScreen 函数;
            renderScreen = (item: ICategory) => {
                return (
                    <Tab.Screen
                        key={item.id}
                        name={item.id}
                        component={Home} // 所有调用的是 Home 组件, 解决这个问题,,到 home.ts 配置动态的 key;
                        options={{ tabBarLabel: item.name }}
                    />
                );
            };

            render() {
                // 4.10-10 根据我的分类,动态生成标签导航器 和 model; myCategorys
                const { myCategorys } = this.props;

                return (
                    <Tab.Navigator
                        initialRouteName="Home"
                        lazy // 异步加载除第一个页面外的其他页面.  lazy={true}  可以省略成 lazy
                        tabBar={this.renderTabBar} // 7.修改首页顶部; 这个可以返回一个组件.
                        sceneContainerStyle={styles.sceneContainer} // 为了taby实现渐变色, 这里设置透明.
                        tabBarOptions={{
                            scrollEnabled: true, // 超过是否允许滚动
                            tabStyle: {
                                width: 50, // TAB宽度
                                padding: 0,
                            },
                            style: { backgroundColor: 'powderblue' },
                            indicatorStyle: {
                                // 这个是下面滚动线条的样式.
                                height: 3,
                                width: 20,
                                marginLeft: 16,
                                borderRadius: 2,
                                backgroundColor: '#f86442',
                            },
                            activeTintColor: '#f86442',
                            inactiveTintColor: '#333',
                            labelStyle: { fontSize: 16 },
                            // showIcon: true,
                            // iconStyle:{}
                        }}
                    >
                        {/* // 5.10-10 根据我的分类,动态生成标签导航器 和 model; 动态生成 Tab 组件; */}
                        {myCategorys.map(this.renderScreen)}
                        {/* 
                            <Tab.Screen name="Home" component={Home} options={{ tabBarLabel:'推荐',}}  />
                            <Tab.Screen name="Vip" component={indexNum} />
                            <Tab.Screen name="小说" component={indexNum} />
                            <Tab.Screen name="直播" component={indexNum} />
                            <Tab.Screen name="儿童" component={indexNum} />
                            <Tab.Screen name="播客" component={indexNum} />
                            <Tab.Screen name="杭州" component={indexNum} />
                            <Tab.Screen name="相声" component={indexNum} /> 
                        */}
                    </Tab.Navigator>
                );
            }
        }
        const styles = StyleSheet.create({
            sceneContainer: {
                backgroundColor: 'transparent',
            },
        });

        export default connector(HomeTabs); // 3.10-10 根据我的分类,动态生成标签导航器 和 model; connector;


  - 动态生成 model,
    安装: yarn add dva-model-extend

    config -> dva.ts
        引入 modelExtend
        import modelExtend from 'dva-model-extend'; // 波浪线,这个第三方库,没有 ts文件.得自己定义一个.

        // 7.10-10 根据我的分类,动态生成标签导航器 和 model;  动态生成 model;  modelExtend 接收很多 model
        // createHomeModel 可能会重复多次的加载; 需要处理下,定义一个接口
        // 解决 createHomeModel 会重复加载多次的问题;
        interface Cached {
            [key: string]: boolean;
        }
        const cached: Cached = {
            home: true, // 定义 home true 表示已经加载过
        }

        function registerModel(model: Model) {
            if(!cached[model.namespace]) { // 如果! 没有找到,我们才会加载.
                app.model(model);
                cached[model.namespace]= true;
            }
        }
        export function createHomeModel(namespace: string) {
            // modelExtend();
            const model = modelExtend(homeModel, {namespace});
            // app.model(model);// 动态插入到 dva里
            registerModel(model);
        }

  -  自定义  库的 ts 文件 (根目录 index.d.ts)

        // impor t modelExtend from 'dva-model-extend'; // 波浪线,这个第三方库,没有 ts文件.得自己在根目录下 新建index.d.ts 文件.
        /**
            //  6.10-10 根据我的分类,动态生成标签导航器 和 model; dva.ts 里引入 modelExtend 是报波浪线错误,所以声明下面这个文件.
            declare module 'dva-model-extend' {
                impor { Model } from 'dva-core-ts';
                export default function modelExtend(...model: Model[]): Model;
            }
        */

  - HomeTabs.tsx
    // 8.10-10 根据我的分类,动态生成标签导航器 和 model;  动态生成 model;  modelExtend 接收很多 model
    引入 createHomeModel() 函数

    // 8.10-10 根据我的分类,动态生成标签导航器 和 model;  引入 createHomeModel() 函数;
		createHomeModel(item.id);
        return (
			<Tab.Screen
                                    key={item.id}
                                    name={item.id}
                                    component={Home} // 所有调用的是 Home 组件, 解决这个问题,,到 home.ts 配置动态的 key;
                                    options={{ tabBarLabel: item.name }}
				initialParams={{  // 9.10-10 根据我的分类,动态生成标签导航器 和 model; namespace,报类型错误 HomeParamList,把 undefined 改成 {nemespace:string}
					namespace: item.id
				}}
			/>
		);


  - Home -> index.tsx
    // 9.10-10 根据我的分类,动态生成标签导航器 和 model; 增加第二个参数props里的{route}.
    const mapStateToProps = ({ home, loading }: RootState, {route}: {route:RouteProp<HomeParamList, string>}) => {
        const {namespace} = route.params;
        state[namespace];
        return{
            //state 改成 对象结构的方法 {home}
            carousels: home.carousels, // ⑩① 加入动态数据 yapi;
            loading: loading.effects['home/fetchChannels'], // 跟异步操作的 type 值是一样的
            channels: home.channels, // 7 首页列表
            hasMore: home.pagination.hasMore, // 17.上拉加载更多; 引入,下面加载的异步操作,要判断是否能加载跟多.
            gradientVisible: home.gradientVisible, // 6.设置滚动上去渐变背景色消失; gradientVisible要再 Models -> hoe.ts 定义个默认值.
        }
    };

  - models -> index.ts  RootState 添加联合类型, & { [key: string]: typeof home.state; }
    export type RootState = {
        ...
    } & {
        [key: string]: typeof home.state;
    }

  - Home -> index.tsx
    // 9.10-10 根据我的分类,动态生成标签导航器 和 model; 增加第二个参数props里的{route}. home 改成 modelState, state.loading;
    const mapStateToProps = (state: RootState, {route}: {route:RouteProp<HomeParamList, string>}) => {
        const {namespace} = route.params;
        const modelState = state[namespace];
        return{
            // state 改成 对象结构的方法 {home}
            namespace, // 将它也传到 props 中,等会其他地方都要用到;
            carousels: modelState.carousels, // ⑩① 加入动态数据 yapi;
            channels: modelState.channels, // 7 首页列表
            hasMore: modelState.pagination.hasMore, // 17.上拉加载更多; 引入,下面加载的异步操作,要判断是否能加载跟多.
            gradientVisible: modelState.gradientVisible, // 6.设置滚动上去渐变背景色消失; gradientVisible要再 Models -> hoe.ts 定义个默认值.
            loading: state.loading.effects[namespace + '/fetchChannels'], // 跟异步操作的 type 值是一样的
        }
    };

    const {namespace} = this.props;
    <Guess namespace={namespace} />

    所有的 type  要改成 带 namespace 的
    type: namespace + '/fetchChannels',

    Guess.tsx 组件 引入 namespace ,  里的 type 也是.

  - TopTabBarWrapper.tsx    home 改成 namespace

    1. 先到 utils -> index.ts 添加个方法 getActiveRouteName 获取路由;
        function getActiveRouteName(state: NavigationState) {
            let route;
            route = state.routes[state.index];

            // while, 判断 有没有多层级 route
            while(route.state && route.state.index) {
                route = route.state.routes[route.state.index];
            }
            return route.name;
        }

        // 再导出去, 
        export { viewportWidth, viewportHeight, wp, hp, getActiveRouteName };
    2. 再到 TopTabBarWrapper页面中:

        const mapStateToProps = (state: RootState, props: MaterialTopTabBarProps) => {
            

            // 11.10-10 根据我的分类,动态生成标签导航器 和 model;  读取路由状态, 上面 "props: MaterialTopTabBarProps" 新加的;{ home }也改成 state,要拿到所有的仓库;
            // getActiveRouteName() 定义在 utils 里
            const routeName = getActiveRouteName(props.state); // 这个 routeName 是和 homespace 保持一致的. HomeTabs 里 name={item.id} ; namespace: item.id;
            const modelState = state[routeName];
            return { // 里面的 home 都改成了 modelState;
                linearColors: modelState.carousels
                    ? modelState.carousels[modelState.activeCarouselIndex] // carousels可能被清空, 而 index 还在, 所以会出现错误.
                        ? modelState.carousels[modelState.activeCarouselIndex].colors
                        : undefined
                    : undefined,
                gradientVisible: modelState.gradientVisible,
            };
        };

    保存,改好后,各个页面的导航 应该是各个页面自己的. (比如说, 推荐, vip, 其他标签, 我向上拖动到什么状态, 回去还是自己拖到的状态.)
    

    

